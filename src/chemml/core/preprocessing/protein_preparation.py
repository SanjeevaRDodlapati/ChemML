"""
Protein Structure Preparation Pipeline for Molecular Docking

This module provides utilities for downloading, converting, and preparing
protein structures from the Protein Data Bank (PDB) for molecular docking experiments.

Classes:
    ProteinPreparationPipeline: Main pipeline for protein structure preparation

Functions:
    download_pdb_file: Download PDB files using BioPython
    convert_to_pdbqt: Convert PDB to PDBQT format using OpenBabel or AutoDockTools
    fetch_metadata: Retrieve protein metadata from RCSB PDB API
"""

import logging
import os
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Union

import requests

try:
    from Bio.PDB.PDBList import PDBList
except ImportError:
    PDBList = None
    logging.warning(
        "BioPython not available. PDB download functionality will be limited."
    )


class ProteinPreparationPipeline:
    """
    Pipeline for preparing protein structures for molecular docking.

    This class handles downloading PDB structures, converting them to PDBQT format,
    and organizing metadata for downstream docking experiments.
    """

    def __init__(
        self,
        receptor_dir: Union[str, Path] = "receptors",
        use_obabel: bool = True,
        verbose: bool = True,
    ):
        """
        Initialize the protein preparation pipeline.

        Args:
            receptor_dir: Directory to store downloaded and converted structures
            use_obabel: Whether to use OpenBabel for PDB->PDBQT conversion
                       (if False, uses AutoDockTools prepare_receptor4.py)
            verbose: Whether to print progress messages
        """
        self.receptor_dir = Path(receptor_dir)
        self.receptor_dir.mkdir(exist_ok=True)
        self.use_obabel = use_obabel
        self.verbose = verbose
        self.protein_data = {}

        # Set up logging
        logging.basicConfig(level=logging.INFO if verbose else logging.WARNING)
        self.logger = logging.getLogger(__name__)

        if PDBList is None:
            self.logger.warning(
                "BioPython not available. Please install with: pip install biopython"
            )

    def download_pdb_file(
        self, pdb_id: str, out_dir: Optional[Path] = None
    ) -> Optional[Path]:
        """
        Download PDB file using BioPython.

        Args:
            pdb_id: PDB identifier (e.g., '1a4g')
            out_dir: Output directory (defaults to self.receptor_dir)

        Returns:
            Path to downloaded PDB file, or None if download failed
        """
        if PDBList is None:
            self.logger.error("BioPython not available for PDB download")
            return None

        if out_dir is None:
            out_dir = self.receptor_dir

        try:
            pdbl = PDBList()
            pdbl.retrieve_pdb_file(pdb_id, pdir=out_dir, file_format="pdb")
            pdb_file = out_dir / f"pdb{pdb_id.lower()}.ent"

            if pdb_file.exists():
                # Rename to standard format
                standard_name = out_dir / f"{pdb_id.lower()}.pdb"
                pdb_file.rename(standard_name)
                return standard_name
            else:
                self.logger.error(f"Failed to download {pdb_id}")
                return None

        except Exception as e:
            self.logger.error(f"Error downloading {pdb_id}: {e}")
            return None

    def convert_to_pdbqt(self, pdb_file: Path, pdbqt_file: Path) -> bool:
        """
        Convert PDB to PDBQT format using OpenBabel or AutoDockTools.

        Args:
            pdb_file: Input PDB file path
            pdbqt_file: Output PDBQT file path

        Returns:
            True if conversion successful, False otherwise
        """
        try:
            if self.use_obabel:
                cmd = ["obabel", str(pdb_file), "-O", str(pdbqt_file)]
            else:
                cmd = [
                    "prepare_receptor4.py",
                    "-r",
                    str(pdb_file),
                    "-o",
                    str(pdbqt_file),
                ]

            result = subprocess.run(cmd, capture_output=True, text=True)

            if result.returncode != 0:
                self.logger.error(
                    f"Conversion failed for {pdb_file.name}:\n{result.stderr}"
                )

                # Create fallback PDBQT file with robust content
                with open(pdbqt_file, "w") as f:
                    f.write(f"# PDBQT file for {pdb_file.name}\n")
                    f.write(
                        "# This file has been generated by the Protein Structure Preparation Pipeline\n"
                    )
                    f.write(
                        "# Warning: Conversion may have failed - please verify before docking\n"
                    )
                return False

            return True

        except Exception as e:
            self.logger.error(f"Conversion error for {pdb_file.name}: {e}")

            # Create fallback file with warning
            with open(pdbqt_file, "w") as f:
                f.write(f"# PDBQT file for {pdb_file.name}\n")
                f.write("# ERROR: Conversion failed due to exception\n")
            return False

    def fetch_metadata(self, pdb_id: str) -> Dict:
        """
        Fetch protein metadata from RCSB PDB API.

        Args:
            pdb_id: PDB identifier

        Returns:
            Dictionary containing metadata (resolution, title, etc.)
        """
        url = f"https://data.rcsb.org/rest/v1/core/entry/{pdb_id}"

        try:
            response = requests.get(url, timeout=10)

            if response.status_code != 200:
                return {
                    "source": "PDB",
                    "resolution": None,
                    "name": f"Protein {pdb_id.upper()}",
                    "status": "metadata_unavailable",
                }

            data = response.json()
            resolution = data.get("rcsb_entry_info", {}).get(
                "resolution_combined", [None]
            )
            resolution = resolution[0] if resolution else None

            title = data.get("struct", {}).get("title", f"Protein {pdb_id.upper()}")

            return {
                "source": "PDB",
                "resolution": resolution,
                "name": title,
                "status": "success",
            }

        except Exception as e:
            self.logger.error(f"Failed to fetch metadata for {pdb_id}: {e}")
            return {
                "source": "PDB",
                "resolution": None,
                "name": f"Protein {pdb_id.upper()}",
                "status": "metadata_failed",
            }

    def prepare_proteins(self, pdb_ids: List[str]) -> Dict:
        """
        Main pipeline: download, convert, and prepare protein structures.

        Args:
            pdb_ids: List of PDB identifiers to process

        Returns:
            Dictionary mapping PDB IDs to their preparation results
        """
        self.protein_data = {}

        if self.verbose:
            print(f"🧬 Processing {len(pdb_ids)} protein structures...")

        for pdb_id in pdb_ids:
            if self.verbose:
                print(f"\n⏬ Processing {pdb_id}...")

            # Download PDB file
            pdb_file = self.download_pdb_file(pdb_id)
            if pdb_file is None or not pdb_file.exists():
                self.logger.error(f"Could not download PDB for {pdb_id}")
                continue

            # Convert to PDBQT
            pdbqt_file = self.receptor_dir / f"{pdb_id}.pdbqt"
            conversion_success = self.convert_to_pdbqt(pdb_file, pdbqt_file)

            if not conversion_success:
                self.logger.warning(
                    f"Conversion issues for {pdb_id}, but continuing..."
                )

            # Fetch metadata
            metadata = self.fetch_metadata(pdb_id)

            # Store results
            self.protein_data[pdb_id] = {
                "pdb_file": str(pdb_file),
                "receptor_file": str(pdbqt_file),
                "name": metadata["name"],
                "source": metadata["source"],
                "resolution": metadata["resolution"],
                "conversion_success": conversion_success,
                "metadata_status": metadata["status"],
            }

            if self.verbose:
                print(f"   ✅ {pdb_id}: {metadata['name']}")
                if metadata["resolution"]:
                    print(f"      Resolution: {metadata['resolution']} Å")

        if self.verbose:
            print(f"\n✅ Successfully processed {len(self.protein_data)} proteins")

        return self.protein_data

    def get_summary(self) -> Dict:
        """
        Get a summary of the protein preparation results.

        Returns:
            Dictionary with summary statistics
        """
        if not self.protein_data:
            return {"status": "no_data", "proteins_processed": 0}

        successful_conversions = sum(
            1 for data in self.protein_data.values() if data["conversion_success"]
        )

        with_resolution = sum(
            1 for data in self.protein_data.values() if data["resolution"] is not None
        )

        return {
            "status": "complete",
            "proteins_processed": len(self.protein_data),
            "successful_conversions": successful_conversions,
            "with_resolution_data": with_resolution,
            "conversion_success_rate": successful_conversions / len(self.protein_data)
            if self.protein_data
            else 0,
        }


# Convenience functions for direct use
def download_pdb_file(pdb_id: str, out_dir: Union[str, Path]) -> Optional[Path]:
    """
    Convenience function to download a single PDB file.

    Args:
        pdb_id: PDB identifier
        out_dir: Output directory

    Returns:
        Path to downloaded file or None if failed
    """
    pipeline = ProteinPreparationPipeline(receptor_dir=out_dir, verbose=False)
    return pipeline.download_pdb_file(pdb_id)


def convert_to_pdbqt(
    pdb_file: Union[str, Path], pdbqt_file: Union[str, Path], use_obabel: bool = True
) -> bool:
    """
    Convenience function to convert a single PDB file to PDBQT.

    Args:
        pdb_file: Input PDB file
        pdbqt_file: Output PDBQT file
        use_obabel: Whether to use OpenBabel (vs AutoDockTools)

    Returns:
        True if successful, False otherwise
    """
    pipeline = ProteinPreparationPipeline(use_obabel=use_obabel, verbose=False)
    return pipeline.convert_to_pdbqt(Path(pdb_file), Path(pdbqt_file))


def fetch_metadata(pdb_id: str) -> Dict:
    """
    Convenience function to fetch metadata for a single protein.

    Args:
        pdb_id: PDB identifier

    Returns:
        Dictionary with metadata
    """
    pipeline = ProteinPreparationPipeline(verbose=False)
    return pipeline.fetch_metadata(pdb_id)


def prepare_proteins_simple(
    pdb_ids: List[str],
    receptor_dir: Union[str, Path] = "receptors",
    use_obabel: bool = True,
) -> Dict:
    """
    Simple interface for preparing multiple proteins.

    Args:
        pdb_ids: List of PDB identifiers
        receptor_dir: Directory for output files
        use_obabel: Whether to use OpenBabel for conversion

    Returns:
        Dictionary mapping PDB IDs to preparation results
    """
    pipeline = ProteinPreparationPipeline(
        receptor_dir=receptor_dir, use_obabel=use_obabel, verbose=True
    )
    return pipeline.prepare_proteins(pdb_ids)
