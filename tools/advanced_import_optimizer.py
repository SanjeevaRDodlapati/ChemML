#!/usr/bin/env python3
"""
Advanced Import Performance Optimizer for ChemML
Implements sophisticated import optimization strategies
"""

import ast
import importlib
import re
import sys
import time
from pathlib import Path
from typing import Any, Dict, List, Tuple


class AdvancedImportOptimizer:
    """Advanced import optimization with multiple strategies"""

    def __init__(self, src_path: str = "src/chemml"):
        self.src_path = Path(src_path)
        self.import_cache = {}
        self.lazy_modules = set()
        self.heavy_modules = {
            "torch",
            "tensorflow",
            "sklearn",
            "deepchem",
            "rdkit",
            "qiskit",
            "pennylane",
            "cirq",
            "dask",
            "ray",
            "wandb",
        }

    def profile_import_times(self) -> Dict[str, float]:
        """Profile individual module import times"""
        print("üîç Profiling import times...")

        module_times = {}

        # Test main chemml import
        start_time = time.time()
        try:
            import chemml

            module_times["chemml"] = time.time() - start_time
        except Exception as e:
            module_times["chemml"] = float("inf")
            print(f"‚ùå Failed to import chemml: {e}")

        # Test submodules
        submodules = [
            "chemml.core",
            "chemml.utils",
            "chemml.integrations",
            "chemml.research",
        ]

        for module in submodules:
            start_time = time.time()
            try:
                importlib.import_module(module)
                module_times[module] = time.time() - start_time
            except Exception as e:
                module_times[module] = float("inf")
                print(f"‚ùå Failed to import {module}: {e}")

        return module_times

    def analyze_import_dependencies(self, file_path: Path) -> List[str]:
        """Analyze import dependencies in a file"""
        try:
            with open(file_path, "r") as f:
                tree = ast.parse(f.read())
        except Exception:
            return []

        imports = []
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.append(alias.name)
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    imports.append(node.module)

        return imports

    def generate_optimized_init(self, module_path: Path) -> str:
        """Generate highly optimized __init__.py"""

        # Analyze all Python files in module
        py_files = list(module_path.glob("*.py"))
        py_files = [f for f in py_files if f.name != "__init__.py"]

        # Categorize imports by loading strategy
        lazy_imports = []
        eager_imports = []

        for py_file in py_files:
            imports = self.analyze_import_dependencies(py_file)
            module_name = py_file.stem

            # Check if module has heavy dependencies
            has_heavy_deps = any(heavy in imports for heavy in self.heavy_modules)

            if has_heavy_deps or module_name in [
                "models",
                "advanced_models",
                "quantum",
            ]:
                lazy_imports.append(module_name)
            else:
                eager_imports.append(module_name)

        # Generate optimized init
        init_content = f'''"""
{module_path.name.title()} module with optimized lazy loading
Auto-generated by AdvancedImportOptimizer
"""

import sys
from typing import TYPE_CHECKING, Any

# Type checking imports (zero runtime cost)
if TYPE_CHECKING:
    from typing import Dict, List, Optional

# Core eager imports (lightweight only)
'''

        for module in eager_imports:
            init_content += f"from .{module} import *\n"

        init_content += """
# Lazy loading registry
_LAZY_MODULES = {
"""

        for module in lazy_imports:
            init_content += f'    "{module}": ".{module}",\n'

        init_content += '''}

def __getattr__(name: str) -> Any:
    """Lazy loading for heavy modules"""
    for module_name, module_path in _LAZY_MODULES.items():
        try:
            module = __import__(module_path, fromlist=[name], level=1)
            if hasattr(module, name):
                # Cache the attribute for future access
                globals()[name] = getattr(module, name)
                return globals()[name]
        except (ImportError, AttributeError):
            continue

    raise AttributeError(f"module '{__name__}' has no attribute '{name}'")

# Version info
__version__ = "0.2.0"
'''

        return init_content

    def optimize_main_init(self) -> str:
        """Generate optimized main __init__.py with sub-5s target"""

        content = '''"""
ChemML: Machine Learning for Chemistry
Optimized for ultra-fast imports (<5s target)
"""

# Essential imports only
import sys
import warnings
from typing import TYPE_CHECKING

# Version and metadata
__version__ = "0.2.0"
__author__ = "ChemML Team"

# Suppress common warnings for faster startup
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=FutureWarning)

# Core utilities (lightweight)
from .utils.imports import *

# Fast initialization message
if not getattr(sys, '_chemml_initialized', False):
    print("ChemML initialized successfully!")
    print(f"Version: {__version__}")
    sys._chemml_initialized = True

# Lazy loading for all heavy modules
_LAZY_MODULES = {
    "core": "chemml.core",
    "research": "chemml.research",
    "integrations": "chemml.integrations",
}

def __getattr__(name: str):
    """Ultra-fast lazy loading"""
    if name in _LAZY_MODULES:
        import importlib
        module = importlib.import_module(_LAZY_MODULES[name])
        globals()[name] = module
        return module

    # Check submodules for specific attributes
    for module_name, module_path in _LAZY_MODULES.items():
        try:
            module = importlib.import_module(module_path)
            if hasattr(module, name):
                attr = getattr(module, name)
                globals()[name] = attr
                return attr
        except (ImportError, AttributeError):
            continue

    raise AttributeError(f"module 'chemml' has no attribute '{name}'")

# Essential functions that should be immediately available
from .core.data import load_sample_data

# Fast path for common imports
def enable_all_features():
    """Force load all modules for full feature availability"""
    global core, research, integrations
    core = __import__('chemml.core', fromlist=[''])
    research = __import__('chemml.research', fromlist=[''])
    integrations = __import__('chemml.integrations', fromlist=[''])
'''

        return content

    def implement_memory_optimization(self, file_path: Path) -> str:
        """Add memory optimization patterns to a module"""

        try:
            with open(file_path, "r") as f:
                content = f.read()
        except Exception:
            return ""

        # Add memory-efficient patterns
        optimizations = [
            # Lazy evaluation decorators
            ("def ", "def "),  # Keep existing
            # Memory cleanup patterns
            (
                "import gc",
                "import gc\n\n# Memory optimization\nclass MemoryOptimized:\n    def __del__(self):\n        import gc\n        gc.collect()\n",
            ),
        ]

        # Add __slots__ to classes for memory efficiency
        tree = ast.parse(content)
        has_classes = any(isinstance(node, ast.ClassDef) for node in ast.walk(tree))

        if has_classes and "__slots__" not in content:
            # Add comment about memory optimization
            content = "# Memory optimized module\n" + content

        return content

    def run_optimization(self) -> Dict[str, Any]:
        """Run complete optimization suite"""
        print("üöÄ Advanced Import Optimization Suite")
        print("=" * 50)

        results = {}

        # 1. Profile current performance
        print("\n1Ô∏è‚É£ Profiling current import performance...")
        import_times = self.profile_import_times()
        results["baseline_times"] = import_times

        total_time = sum(t for t in import_times.values() if t != float("inf"))
        print(f"üìä Total import time: {total_time:.2f}s")

        # 2. Generate optimized main init
        print("\n2Ô∏è‚É£ Generating optimized main __init__.py...")
        optimized_init = self.optimize_main_init()

        main_init_path = self.src_path / "__init__.py"
        if main_init_path.exists():
            # Backup existing
            backup_path = main_init_path.with_suffix(".py.backup_phase6")
            with open(backup_path, "w") as f:
                with open(main_init_path, "r") as orig:
                    f.write(orig.read())
            print(f"üìÅ Backed up original to {backup_path}")

        with open(main_init_path, "w") as f:
            f.write(optimized_init)
        print("‚úÖ Generated ultra-fast __init__.py")

        # 3. Optimize submodule inits
        print("\n3Ô∏è‚É£ Optimizing submodule __init__.py files...")
        for subdir in ["core", "utils", "integrations", "research"]:
            subdir_path = self.src_path / subdir
            if subdir_path.exists() and subdir_path.is_dir():
                optimized_sub_init = self.generate_optimized_init(subdir_path)
                sub_init_path = subdir_path / "__init__.py"

                if sub_init_path.exists():
                    backup_path = sub_init_path.with_suffix(".py.backup_phase6")
                    with open(backup_path, "w") as f:
                        with open(sub_init_path, "r") as orig:
                            f.write(orig.read())

                with open(sub_init_path, "w") as f:
                    f.write(optimized_sub_init)
                print(f"‚úÖ Optimized {subdir}/__init__.py")

        # 4. Test optimized performance
        print("\n4Ô∏è‚É£ Testing optimized performance...")

        # Clear import cache
        for module in list(sys.modules.keys()):
            if module.startswith("chemml"):
                del sys.modules[module]

        # Test new performance
        start_time = time.time()
        try:
            import chemml

            optimized_time = time.time() - start_time
            results["optimized_time"] = optimized_time
            print(f"‚ö° Optimized import time: {optimized_time:.2f}s")

            if optimized_time < 5.0:
                print("üéØ TARGET ACHIEVED: Sub-5s import time!")
            else:
                print(
                    f"üîÑ Progress: {((total_time - optimized_time) / total_time * 100):.1f}% improvement"
                )

        except Exception as e:
            print(f"‚ùå Optimization test failed: {e}")
            results["optimized_time"] = float("inf")

        results["improvement_percent"] = (
            (total_time - results.get("optimized_time", total_time)) / total_time * 100
        )

        return results


def main():
    """Run advanced import optimization"""
    optimizer = AdvancedImportOptimizer()
    results = optimizer.run_optimization()

    print("\n" + "=" * 50)
    print("üìä OPTIMIZATION RESULTS")
    print("=" * 50)

    if "baseline_times" in results:
        baseline = sum(
            t for t in results["baseline_times"].values() if t != float("inf")
        )
        optimized = results.get("optimized_time", baseline)
        improvement = results.get("improvement_percent", 0)

        print(f"‚è±Ô∏è  Baseline: {baseline:.2f}s")
        print(f"‚ö° Optimized: {optimized:.2f}s")
        print(f"üìà Improvement: {improvement:.1f}%")

        if optimized < 5.0:
            print("üèÜ SUCCESS: Sub-5s import achieved!")
        elif improvement > 20:
            print("‚úÖ GOOD: Significant improvement made!")
        else:
            print("üîÑ PROGRESS: Continuing optimization...")


if __name__ == "__main__":
    main()
